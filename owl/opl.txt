opl: own programming language

inspired by
- tcl
- python
- c
- scheme
- haskell
- rc
- go
- json
- bnf
- asm

targets
- minimum language specification
- simple parsing
- avoid magic numbers
- single coding convention

notes
- polish notation
- from tcl: "everything is a string"
- go: multiple returns
- go: interfaces
- json: entrada y retorno de variables
- from python:
  - newline: instruction separator
  - indentation: avoids instruction grouping
- reference passsing by default
- nested comments
- se elimina if ya que se puede hacer lo mismo con switch
- se ha de discernir entre switch con o sin break
- se eliminan for y do ya que se puede hacer lo mismo con while
- una variable puede contener un valor o una funcion
  - la asignacion se hace por referencia
    - si se asigna una funcion, se asigna su proceso, no su resultado concreto
    - si se asigna una variable, se asigna su direccion de memoria
    - se debe elegir un operador para obtener valor en lugar de referencia
- la indentacion indica que  se siguen pasando argumentos a la funcion
  - es voluntaria. el espacio separa los distintos argumentos
- los literales van aparte
  - son funciones especiales en las que se usan caracteres de escape para
    hacer referencia a entes no literales
    - <lt>
    - <gt>
    - <def arg ...>
- todas las definiciones estaran conpuestas de [a..z]
- como se haran las llamadas al sistema?
- las definiciones reciben y devuelven un unico argumento, que puede ser
  cualquier tipo de dato como una estructura de varios miembros
- se puede suprimir los bucles en favor de la recursividad

operadores (actuan como las definiciones pero estan predefinidas)
  = igual a
  > mayor que
  < menor que
  ! negacion
  ? switch
  @ loop

operadores sin espacio
  ! desreferencia
  . miembro
  : asignacion

variables especiales
  ; siguiente argumento sin examinar

tipos basicos de datos
- texto
- numero
- expresion

snippets

/* c */

    2 * 3

/* opl 1 */

    * 2 3

/* opl 2 */

    *
        2
        3

/* opl 3 */

    * {2 3)

/* opl 4 */

    * {2, 3)

/* opl 5 */

    * {
        2
        3
    )

/* c */

    a==b

/* opl */

    = a b

/* c */

    a<b

/* opl */

    < a b

/* c */

    a>b

/* opl */

    > a b

/* c */

    !a

/* opl */

    ! a

/* c */

    a>=b

/* opl */

    ! < a b

/* c */

    a<=b

/* opl */

    ! > a b

/* c */

    if (a<=b)
        c=a;
    else
        c=b;

/* opl 1 */

    ? ! > a b
        true
            : c a
        false
            : c b

/* opl 1b */

    ? true
        ! > a b
            : c a
        otherwise
            : c b

/* c */

    mult (int a, int b) {
        return a * b;
    }

    main() {
        printf ("%d\n", mult (2, 3));
    }

/* opl 1 */

    : * sys . expr . @ mult ; ;
    :
        sys . @ echo @ * 2 3

/* opl 2 */

    :* sys .expr .!mult ; ;
    :
        sys .!echo !* 2 3

/* opl 3 */

    :* sys.expr.mult ; ;
    :
        sys.echo * 2 3

/* opl 4 */

    :* sys .expr .mult ; ;
    :
        sys .echo * 2 3

/* opl 5 */

    :* sys .expr .!mult ; ;
    : sys .!echo !* {2 3}

/* opl 6 */

    :* sys .expr .!mult ; ;
    : sys .!echo !*
        2
        3

